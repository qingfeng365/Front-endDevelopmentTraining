# 第04讲 启用路由

## 创建自带路由的项目

`--routing`

使用 `--routing` 参数

如:

`ng new myapp --routing`


## 在现有项目中使用路由

- 创建路由模块
- 根模块引入路由模块
- 根视图定义路由占位符

### 创建路由模块

官方推荐路由模块命名:

`app-routing.module.ts`

#### 路由模块写法

要点:

- 引入 `Routes, RouterModule`
- Routes 用于 定义路由规则对象
- RouterModule 用于 创建根路由树
- 引入 路由要使用的 组件
- 导出路由模块

源码示例:

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeComponent } from 'app/home/home.component';
import { ProductComponent } from 'app/product/product.component';


const routes: Routes = [
  {
    path: '',
    component: HomeComponent,
  },
  {
    path: 'product',
    component: ProductComponent,
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

```

### 根模块引入路由模块

```ts
//...
import { AppRoutingModule } from './app-routing.module';

//...

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    ProductComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AppRoutingModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### 根视图定义路由占位符

路由占位符: `router-outlet` (路由插座)

```html
<a [routerLink]="['']">主页</a>
<a [routerLink]="['/product']">商品详情</a>
<router-outlet></router-outlet>
```


## 关于使用路由的方法

### 如何在视图定义导航到某个路由

绑定属性: `routerLink`

如:

```html
<a [routerLink]="['/product']">商品详情</a>
```

### routerLink 与 href 的区别

- routerLink 是数组表达式, 
  - 数组的元素对应 路由配置中 path 的 / 数量 + 1;
  - 如 `aaa/:aid/bbbb/:bid`
  - 则 routerLink = ['aaa',1,'bbbb',2]
- routerLink 会防止页面重新加载, href 会引起页面刷新
- routerLink 可用于任何标签
- routerLink 可与 routerLinkActive 配合使用

### routerLink的附加说明

routerLink 可以不使用属性绑定, 即直接使用 `routerLink = '/xxxx'`

此时routerLink为静态网址,不要写成数组形式

### 在控制器中如何获取当前路由

`ActivatedRoute` 对象

### 在控制器中如何使用代码导航到某个路由

- 注入 Router 对象
- 调用 Router.navigate 方法导航

####　注入方法

-　在组件　｀constructor｀　方法指定要注入的对象
-　系统会自动创建请求注入的实例,并放到 组件的 this. 属性中

#### 代码示例

```ts
import { Component } from '@angular/core';
import {Router} from '@angular/router';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app works!';

  constructor(private router: Router){

  }

  toProductDetail(){
    this.router.navigate(['/product'])
  }
}
```

说明:

- private 不是必须,可以不写,推荐要写
- navigate的参数是数组,意义与 `[routerLink]` 的用法是一样的

## 路由不存在时的处理

当路由不存在时,系统会在控制台报错

`Error: Cannot match any routes. URL Segment: 'xxxx'`

同时 <router-outlet></router-outlet> 节点后面没有内容

### 不存在时的通用处理

- 创建 用于页面不存在时,要显示的组件
- 增加通配符路由到路由定义的最后

#### 创建组件

`ng g c code404`


####　定义路由

```ts
//......
import { Code404Component } from "app/code404/code404.component";


const routes: Routes = [
  {
    path: '',
    component: HomeComponent,
  },
  {
    path: 'product',
    component: ProductComponent,
  },
  {
    path:'**',
    component: Code404Component,
  }
];
```

## 如何导航路由时传递参数

### 使用查询参数方式-queryParams

#### 形式一:

在视图中,使用属性绑定 `[queryParams]`

```html
<a [routerLink]="['/product']" [queryParams]="{id:1}">商品详情</a>
```

queryParams 绑定对象

#### 形式二:

在浏览器地址栏后面输入 `?id=1`

`http://localhost:4200/product?id=1`

>
形式一与形式二是等价,点击形式一的导航,会同步在浏览器地址栏中



#### 控制器接收queryParams的方法

注入 `ActivatedRoute` 对象

代码示例:

```ts
import { ActivatedRoute } from '@angular/router';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-product',
  templateUrl: './product.component.html',
  styleUrls: ['./product.component.css']
})
export class ProductComponent implements OnInit {
  private productId: number;
  constructor(private routeInfo: ActivatedRoute) {
  }
  ngOnInit() {
    this.productId = this.routeInfo.snapshot.queryParams.id;
  }
}
```

注意: 

- 接收queryParams的方法,应写在 子组件中, 即路由要切换的组件
- 使用 `ActivatedRoute` 的 snapshot 属性的 queryParams属性


### 使用路径参数方式-path

####　步骤1: 路由定义时指定参数占位符

```ts
  {
    path: 'product/:id',
    component: ProductComponent,
  },
```

#### 步骤2: 使用路径参数

方式一:

```html
[routerLink]="['/product',1]"
```

注意,路径参数是通过数组方式定义的

方式二:


在浏览器地址栏后面输入 `/1`

`http://localhost:4200/product/1`


#### 步骤3: 控制器接收params(路径参数)的方法

```ts
  this.productId = this.routeInfo.snapshot.params.id;
```

### 使用路由定义静态参数

注意:该方法不会影响地址栏的显示

```ts
  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
  },
```

```ts
    console.log(this.routeInfo.snapshot.data);
```

- data可为任意对象或数组


## 关于参数快照与参数订阅

### 问题的来源

子组件 `ngOnInit()` 方法, 如果当前路由还没有创建过该组件时,则会触发,

如果当前路由已经创建该组件,则不会再创建,也就不会再触发`ngOnInit()` 方法

这种情况一般出现在主从结构页面

###　如何解决

```ts
import { Params, ActivatedRoute } from '@angular/router';

...

  ngOnInit() {
    this.routeInfo.params.subscribe(
      (params: Params) => this.productId = params.id
    );
  }

```

> 注意:这里的写法是不严谨的, 因为订阅还需要关闭,
因此需要存储subscribe,以便在组件生命周期结束时关闭订阅.
否则内存会泄漏


### 完整写法

```ts
import { Params, ActivatedRoute } from '@angular/router';
import { Component, OnInit, OnDestroy } from '@angular/core';
import { Subscription } from "rxjs/Subscription";

//......

  private subscribe: Subscription;

//.......
  ngOnInit() {
    this.subscribe = this.routeInfo.params.subscribe(
      (params: Params) => this.productId = params.id);

    console.log(this.routeInfo.snapshot.data);
  }
  ngOnDestroy(){
    this.subscribe.unsubscribe();
  }

```

## 重定向路由

```ts
  {
    path: '',
    redirectTo: '/home',
    pathMatch: 'full',
  },
  {
    path: 'home',
    component: HomeComponent,
  },
```

# Route的文档说明

```ts
/**
 * @whatItDoes Represents router configuration.
 *
 * @description
 * `Routes` is an array of route configurations. Each one has the following properties:
 *
 * - `path` is a string that uses the route matcher DSL.
 * - `pathMatch` is a string that specifies the matching strategy.
 * - `matcher` defines a custom strategy for path matching and supersedes `path` and `pathMatch`.
 *   See {@link UrlMatcher} for more info.
 * - `component` is a component type.
 * - `redirectTo` is the url fragment which will replace the current matched segment.
 * - `outlet` is the name of the outlet the component should be placed into.
 * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See
 *   {@link CanActivate} for more info.
 * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See
 *   {@link CanActivateChild} for more info.
 * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See
 *   {@link CanDeactivate} for more info.
 * - `canLoad` is an array of DI tokens used to look up CanDeactivate handlers. See
 *   {@link CanLoad} for more info.
 * - `data` is additional data provided to the component via `ActivatedRoute`.
 * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more
 *   info.
 * - `runGuardsAndResolvers` defines when guards and resovlers will be run. By default they run only
 *    when the matrix parameters of the route change. When set to `paramsOrQueryParamsChange` they
 *    will also run when query params change. And when set to `always`, they will run every time.
 * - `children` is an array of child route definitions.
 * - `loadChildren` is a reference to lazy loaded child routes. See {@link LoadChildren} for more
 *   info.
 *
 * ### Simple Configuration
 *
 * ```
 * [{
 *   path: 'team/:id',
  *  component: Team,
 *   children: [{
 *     path: 'user/:name',
 *     component: User
 *   }]
 * }]
 * ```
 *
 * When navigating to `/team/11/user/bob`, the router will create the team component with the user
 * component in it.
 *
 * ### Multiple Outlets
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team
 * }, {
 *   path: 'chat/:user',
 *   component: Chat
 *   outlet: 'aux'
 * }]
 * ```
 *
 * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to
 * the chat component. The chat component will be placed into the aux outlet.
 *
 * ### Wild Cards
 *
 * ```
 * [{
 *   path: '**',
 *   component: Sink
 * }]
 * ```
 *
 * Regardless of where you navigate to, the router will instantiate the sink component.
 *
 * ### Redirects
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [{
 *     path: 'legacy/user/:name',
 *     redirectTo: 'user/:name'
 *   }, {
 *     path: 'user/:name',
 *     component: User
 *   }]
 * }]
 * ```
 *
 * When navigating to '/team/11/legacy/user/jim', the router will change the url to
 * '/team/11/user/jim', and then will instantiate the team component with the user component
 * in it.
 *
 * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the
 * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.
 *
 * ### Empty Path
 *
 * Empty-path route configurations can be used to instantiate components that do not 'consume'
 * any url segments. Let's look at the following configuration:
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [{
 *     path: '',
 *     component: AllUsers
 *   }, {
 *     path: 'user/:name',
 *     component: User
 *   }]
 * }]
 * ```
 *
 * When navigating to `/team/11`, the router will instantiate the AllUsers component.
 *
 * Empty-path routes can have children.
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   children: [{
 *     path: '',
 *     component: WrapperCmp,
 *     children: [{
 *       path: 'user/:name',
 *       component: User
 *     }]
 *   }]
 * }]
 * ```
 *
 * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with
 * the user component in it.
 *
 * An empty path route inherits its parent's params and data. This is because it cannot have its
 * own params, and, as a result, it often uses its parent's params and data as its own.
 *
 * ### Matching Strategy
 *
 * By default the router will look at what is left in the url, and check if it starts with
 * the specified path (e.g., `/team/11/user` starts with `team/:id`).
 *
 * We can change the matching strategy to make sure that the path covers the whole unconsumed url,
 * which is akin to `unconsumedUrl === path` or `$` regular expressions.
 *
 * This is particularly important when redirecting empty-path routes.
 *
 * ```
 * [{
 *   path: '',
 *   pathMatch: 'prefix', //default
 *   redirectTo: 'main'
 * }, {
 *   path: 'main',
 *   component: Main
 * }]
 * ```
 *
 * Since an empty path is a prefix of any url, even when navigating to '/main', the router will
 * still apply the redirect.
 *
 * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to
 * '/'.
 *
 * ```
 * [{
 *   path: '',
 *   pathMatch: 'full',
 *   redirectTo: 'main'
 * }, {
 *   path: 'main',
 *   component: Main
 * }]
 * ```
 *
 * ### Componentless Routes
 *
 * It is useful at times to have the ability to share parameters between sibling components.
 *
 * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both
 * of them require some id parameter.
 *
 * One way to do that would be to have a bogus parent component, so both the siblings can get the id
 * parameter from it. This is not ideal. Instead, you can use a componentless route.
 *
 * ```
 * [{
 *    path: 'parent/:id',
 *    children: [
 *      { path: 'a', component: MainChild },
 *      { path: 'b', component: AuxChild, outlet: 'aux' }
 *    ]
 * }]
 * ```
 *
 * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux
 * child components next to each other. In this example, the application component
 * has to have the primary and aux outlets defined.
 *
 * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into
 * the `params`, `data`, and `resolve` of the children. This is done because there is no component
 * that can inject the activated route of the componentless parent.
 *
 * This is especially useful when child components are defined as follows:
 *
 * ```
 * [{
 *    path: 'parent/:id',
 *    children: [
 *      { path: '', component: MainChild },
 *      { path: '', component: AuxChild, outlet: 'aux' }
 *    ]
 * }]
 * ```
 *
 * With this configuration in place, navigating to '/parent/10' will create the main child and aux
 * components.
 *
 * ### Lazy Loading
 *
 * Lazy loading speeds up our application load time by splitting it into multiple bundles, and
 * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of
 * providing the children property, you can provide the `loadChildren` property, as follows:
 *
 * ```
 * [{
 *   path: 'team/:id',
 *   component: Team,
 *   loadChildren: 'team'
 * }]
 * ```
 *
 * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.
 * Then it will extract the set of routes defined in that NgModule, and will transparently add
 * those routes to the main configuration.
 *
 * @stable use Routes
 */
export declare type Routes = Route[];
```

