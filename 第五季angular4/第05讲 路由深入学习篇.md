
# 第05讲 路由深入学习篇


## 使用子路由

用途: 当一个组件内部,又需要根据不同时间切换局部内容时使用

### 定义子路由的方法

```ts
  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }]
  },
```

- children 是数组,元素属性与普通路由一样

### 在组件模板内部启用路由插座router-outlet

```html
<p>
  product works!
</p>
<p>id:{{productId}}</p>
<a [routerLink]="['./']">商品描述</a>
<a [routerLink]="['./seller',100]">销售员信息</a>
<router-outlet></router-outlet>
```

## 使用辅助路由

### 定义辅助路由插座

```html
<router-outlet></router-outlet>
<router-outlet name="aux"></router-outlet>
```

带有name的`router-outlet`为辅助路由插座

### 定义辅助路由配置

```
  {
    path: 'chat',
    component: ChatComponent,
    outlet: 'aux',
  },
```

### 在导航中指定辅助路由

```html
  <a [routerLink]="[{outlets: {aux: 'chat'}}]">Open Chat</a>
  <a [routerLink]="[{outlets: {primary:'home',aux: null}}]">Close Chat</a>
```

- primary: 用于指定 主路由插座要处理的组件,可以不指定

## 路由守卫

进入或离开路由的条件

- CanActivate: 可进入
- CanDeactivate: 可离开 
- Resolve: 数据已准备完成

### CanActivate

新建路由守卫文件

`/src/app/guard/login.guard.ts`

```ts
import { RouterStateSnapshot, ActivatedRouteSnapshot, CanActivate } from '@angular/router';
import { Observable } from 'rxjs/Observable';

export class LoginGuard implements CanActivate {
  canActivate(route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {
    const loggedIn: boolean = Math.random() < 0.5;
    if (!loggedIn) {
      console.log('LoginGuard:用户未登录' + new Date());
    }
    return loggedIn;
  }
}
```

说明: 实现 `CanActivate` 接口的 `canActivate` 方法

在路由配置中定义使用守卫

`/src/app/app-routing.module.ts`

```ts
//...
import { LoginGuard } from 'app/guard/login.guard';
//...

  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }],
    canActivate: [LoginGuard],
  },

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard],
})
export class AppRoutingModule { }

```

说明: 路由守卫需要依赖注入才能使用


### CanDeactivate

新建路由守卫文件

`/src/app/guard/unsaved.guard.ts`

```ts
import { RouterStateSnapshot, ActivatedRouteSnapshot, CanDeactivate } from '@angular/router';
import { ProductComponent } from 'app/product/product.component';
import { Observable } from 'rxjs/Observable';

export class UnsavedGuard implements CanDeactivate<ProductComponent> {
  canDeactivate(component: ProductComponent,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot): boolean |
    Observable<boolean> | Promise<boolean> {
    return window.confirm('你还没有保存.确定要离开么?');
  }

}

```

说明: 

- CanDeactivate要定义成泛型, 泛型为组件

在路由配置中定义使用守卫

`/src/app/app-routing.module.ts`

```ts
//...
import { LoginGuard } from 'app/guard/login.guard';
import { UnsavedGuard } from 'app/guard/unsaved.guard';
//...

  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }],
    canActivate: [LoginGuard],
    canDeactivate: [UnsavedGuard],
  },

//...
  @NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard, UnsavedGuard],
})
export class AppRoutingModule { }
```

### Resolve

创建产品类

`/src/app/product/product.component.ts`

```ts
export class Product {
  constructor(public id: number, public name: string) {

  }
}
```


新建路由守卫文件

`/src/app/guard/product.resolve.ts`

```ts
import {
  RouterStateSnapshot,
  ActivatedRouteSnapshot, Resolve, Router
} from '@angular/router';
import { Product } from 'app/product/product.component';
import { Observable } from 'rxjs/Observable';
import { Injectable } from '@angular/core';


@Injectable()
export class ProductResolve implements Resolve<Product> {
  constructor(private router: Router) {
  }
  resolve(route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot):
    Product | Observable<Product> |
    Promise<Product> {
    const productId: number = parseInt(route.params.id, 10);
    if (productId === 1) {
      return new Product(1, 'iphone7');
    } else {
      this.router.navigate(['/home']);
      return undefined;
    }
  }
}

```

注意:

- 要使用 `@Injectable()` 装饰器, 因为要 依赖注入 `Router`
- route.params.id 是字符,要转换成整型


修改 `ProductComponent` 接收 Resolve 传递的数据

Resolve守卫将数据放到data属性

```ts

export class ProductComponent implements OnInit {
  private productId: number;
  private productName: string;
  private subscribe: Subscription;

  constructor(private routeInfo: ActivatedRoute) {
  }
  ngOnInit() {
    this.subscribe = this.routeInfo.data.subscribe(
      (data: { product: Product }) => {
        this.productId = data.product.id;
        this.productName = data.product.name;
      });
  }

  ngOnDestroy() {
    this.subscribe.unsubscribe();
  }
}
```

修改 `ProductComponent` 的模板

```html
<div class="product">
  <p>
    product works!
  </p>
  <p>id:{{productId}}</p>
  <p>name:{{productName}}</p>
  <a [routerLink]="['./']">商品描述</a>
  <a [routerLink]="['./seller',100]">销售员信息</a>
  <router-outlet></router-outlet>
</div>
```

在路由配置中定义使用守卫

```ts

//...
import { ProductResolve } from './guard/product.resolve';
//...

  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }],
    canActivate: [LoginGuard],
    canDeactivate: [UnsavedGuard],
    resolve: {
      product: ProductResolve,
    }
  },

//...

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard, UnsavedGuard, ProductResolve],
})

```

