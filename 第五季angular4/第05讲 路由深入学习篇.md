
# 第05讲 路由深入学习篇

## RouterLink 指令简介

非常好的说明：

(https://segmentfault.com/a/1190000009255145)[https://segmentfault.com/a/1190000009255145]

### 多段路由带参数的写法:

RouterLink 指令可以让你链接到应用程序的特定部分。若链接是静态的，我们可以按照以下的方式，来使用该指令：

<a routerLink="/user/bob">link to user component</a>

如果你需要使用动态值生成链接地址，你可以传递一个路径片段 (segments) 的数组，然后再传递每个段的参数。例如使用 ['/team', teamId, 'user', userName, {details: true}] 数组，意味着我们想要生成一个链接到 /team/11/user/bob;details=true 。

多个静态段 (segments) 能够被合并为一个，例如 ['/team/11/user', userName, {details: true}] 。

第一个路径片段可以以 / ，./ 或 ../ 开头：

    如果以 / 开头，路由将从根路由开始查找

    如果以 ./ 开头或没有使用 / ，则路由将从当前激活路由的子路由开始查找

    如果以 ../ 开头，路由往上一级查找

你可以使用以下方式设置查询参数和片段 (fragment)：

<a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
   link to user component
</a>

RouterLink 指令将基于以上设定的输入参数，生成如下链接：/user/bob#education?debug=true 。此外我们可以通过 queryParamsHandling 属性来声明如何处理查询参数，可用的选项是：

    merge - 合并已有的 queryParams 到当前的 queryParams 中

    preserve - 保存当前的 queryParams

    default ('') - 仅使用查询参数

具体使用示例如下：

<a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
    link to user component
</a>

### RouterLink 指令输入属性

// 设置URL相关的查询参数
@Input() queryParams: {[k: string]: any};

// 设置URL上的hash fragment
@Input() fragment: string; 

// 设置查询参数处理方式：merge、preserve 、default 
@Input() queryParamsHandling: QueryParamsHandling; 

// 设置是否保留fragment
@Input() preserveFragment: boolean;

// 设置页面导航时，是否把新的状态添加到历史记录中
@Input() skipLocationChange: boolean;

// 设置页面导航的同时，是否替换历史记录中的当前状态
@Input() replaceUrl: boolean;
 
// 设置commands参数信息，如：['/user/bob']
@Input()
set routerLink(commands: any[]|string) {
    if (commands != null) {
      this.commands = Array.isArray(commands) ? commands : [commands];
    } else {
      this.commands = [];
    }
}


## 使用子路由

用途: 当一个组件内部,又需要根据不同时间切换局部内容时使用

### 定义子路由的方法

```ts
  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }]
  },
```

- children 是数组,元素属性与普通路由一样

### 在组件模板内部启用路由插座router-outlet

```html
<p>
  product works!
</p>
<p>id:{{productId}}</p>
<a [routerLink]="['./']">商品描述</a>
<a [routerLink]="['./seller',100]">销售员信息</a>
<router-outlet></router-outlet>
```

## 使用辅助路由

### 定义辅助路由插座

```html
<router-outlet></router-outlet>
<router-outlet name="aux"></router-outlet>
```

带有name的`router-outlet`为辅助路由插座

### 定义辅助路由配置

```
  {
    path: 'chat',
    component: ChatComponent,
    outlet: 'aux',
  },
```

### 在导航中指定辅助路由

```html
  <a [routerLink]="[{outlets: {aux: 'chat'}}]">Open Chat</a>
  <a [routerLink]="[{outlets: {primary:'home',aux: null}}]">Close Chat</a>
```

- primary: 用于指定 主路由插座要处理的组件,可以不指定

## 路由守卫

进入或离开路由的条件

- CanActivate: 可进入
- CanDeactivate: 可离开 
- Resolve: 数据已准备完成

### CanActivate

新建路由守卫文件

`/src/app/guard/login.guard.ts`

```ts
import { RouterStateSnapshot, ActivatedRouteSnapshot, CanActivate } from '@angular/router';
import { Observable } from 'rxjs/Observable';

export class LoginGuard implements CanActivate {
  canActivate(route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {
    const loggedIn: boolean = Math.random() < 0.5;
    if (!loggedIn) {
      console.log('LoginGuard:用户未登录' + new Date());
    }
    return loggedIn;
  }
}
```

说明: 实现 `CanActivate` 接口的 `canActivate` 方法

在路由配置中定义使用守卫

`/src/app/app-routing.module.ts`

```ts
//...
import { LoginGuard } from 'app/guard/login.guard';
//...

  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }],
    canActivate: [LoginGuard],
  },

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard],
})
export class AppRoutingModule { }

```

说明: 路由守卫需要依赖注入才能使用


### CanDeactivate

新建路由守卫文件

`/src/app/guard/unsaved.guard.ts`

```ts
import { RouterStateSnapshot, ActivatedRouteSnapshot, CanDeactivate } from '@angular/router';
import { ProductComponent } from 'app/product/product.component';
import { Observable } from 'rxjs/Observable';

export class UnsavedGuard implements CanDeactivate<ProductComponent> {
  canDeactivate(component: ProductComponent,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,
    nextState?: RouterStateSnapshot): boolean |
    Observable<boolean> | Promise<boolean> {
    return window.confirm('你还没有保存.确定要离开么?');
  }

}

```

说明: 

- CanDeactivate要定义成泛型, 泛型为组件

在路由配置中定义使用守卫

`/src/app/app-routing.module.ts`

```ts
//...
import { LoginGuard } from 'app/guard/login.guard';
import { UnsavedGuard } from 'app/guard/unsaved.guard';
//...

  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }],
    canActivate: [LoginGuard],
    canDeactivate: [UnsavedGuard],
  },

//...
  @NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard, UnsavedGuard],
})
export class AppRoutingModule { }
```

### Resolve

创建产品类

`/src/app/product/product.component.ts`

```ts
export class Product {
  constructor(public id: number, public name: string) {

  }
}
```


新建路由守卫文件

`/src/app/guard/product.resolve.ts`

```ts
import {
  RouterStateSnapshot,
  ActivatedRouteSnapshot, Resolve, Router
} from '@angular/router';
import { Product } from 'app/product/product.component';
import { Observable } from 'rxjs/Observable';
import { Injectable } from '@angular/core';


@Injectable()
export class ProductResolve implements Resolve<Product> {
  constructor(private router: Router) {
  }
  resolve(route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot):
    Product | Observable<Product> |
    Promise<Product> {
    const productId: number = parseInt(route.params.id, 10);
    if (productId === 1) {
      return new Product(1, 'iphone7');
    } else {
      this.router.navigate(['/home']);
      return undefined;
    }
  }
}

```

注意:

- 要使用 `@Injectable()` 装饰器, 因为要 依赖注入 `Router`
- route.params.id 是字符,要转换成整型


修改 `ProductComponent` 接收 Resolve 传递的数据

Resolve守卫将数据放到data属性

```ts

export class ProductComponent implements OnInit {
  private productId: number;
  private productName: string;
  private subscribe: Subscription;

  constructor(private routeInfo: ActivatedRoute) {
  }
  ngOnInit() {
    this.subscribe = this.routeInfo.data.subscribe(
      (data: { product: Product }) => {
        this.productId = data.product.id;
        this.productName = data.product.name;
      });
  }

  ngOnDestroy() {
    this.subscribe.unsubscribe();
  }
}
```

修改 `ProductComponent` 的模板

```html
<div class="product">
  <p>
    product works!
  </p>
  <p>id:{{productId}}</p>
  <p>name:{{productName}}</p>
  <a [routerLink]="['./']">商品描述</a>
  <a [routerLink]="['./seller',100]">销售员信息</a>
  <router-outlet></router-outlet>
</div>
```

在路由配置中定义使用守卫

```ts

//...
import { ProductResolve } from './guard/product.resolve';
//...

  {
    path: 'product/:id',
    component: ProductComponent,
    data: { ok: 1 },
    children: [{
      path: '',
      component: ProductDescComponent,
    }, {
      path: 'seller/:id',
      component: SellerInfoComponent,
    }],
    canActivate: [LoginGuard],
    canDeactivate: [UnsavedGuard],
    resolve: {
      product: ProductResolve,
    }
  },

//...

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
  providers: [LoginGuard, UnsavedGuard, ProductResolve],
})

```

