# 第07讲 依赖注入

## 在模块中引入要注入的服务类

```ts
@NgModule({
	providers: [ProductService],
})
```

上面写法等价于

```ts
@NgModule({
	providers: [{provide:ProductService, useClass:ProductService}],
})
```


`provide:ProductService` 中的 `ProductService` 为唯一符号 (token), 
可以与类不同名

当模块定义了可注入的服务类后,在同一模块中的组件就可通过依赖注入机制使用服务

```ts
@Component({
	//...
})
export class ProductComponent implements OnInit {
  product: Product;
  constructor(private productService: ProductService) {
		this.product = this.productService.getProduct();
  }
}

```

> 注意: 
>
`constructor(private productService: ProductService)` 
中的 `ProductService` 是指的 `token`, 在模块的providers定义的 `token`,
不是 `class ProductService`, 换句话说, 这个`token`在注入时实际上可以用别的类实现,
取决于`providers` 中 `useClass`的定义



## 依赖注入的好处

- `ProductComponent` 与 `class ProductService` 解绑
- 提高可测性, `class ProductService` 可以提供不同的实现,来进行测试
- 比如 `class ProductService` 还没开发好, 或者测试时不处理网络等等
- 此时,可通过 模拟静态处理的 另一个 `class AProductService` 
- 来注入 `ProductService` (token)
- 而不需要更改 `ProductComponent` 本身的代码


## 依赖注入的概念

- 注入器
- 提供器

### 注入器

- 注入器是系统提供的一种机制, 用于 `constructor(xxx: XXX)` 中,完成注入
- 注入器只是根据一定规则,去获取提供器的注入规则

### 提供器

- `providers: [{provide:ProductService, useClass:ProductService}],`
- 这里就是一个提供器

#### 提供器的三种定义方式

- 简写模式: `providers: [ProductService],`
- 完整模式: `providers: [{provide:ProductService, useClass:ProductService}],`
- 工厂模式: `providers: [{provide:ProductService, useFactory:()=>{}}],`



