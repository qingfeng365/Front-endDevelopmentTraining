# 第13讲 组件间通讯

## 组件通讯的内容

- 组件的输入输出属性 (父子组件)
- 使用中间人模式传递数据 (非父子组件)
- 组件生命周期及变化发现机制


## 组件的输入属性

### 创建子组件

`ng g c order`

`/src/app/order/order.component.ts`


```ts
import { Component, OnInit, Input } from '@angular/core';

@Component({
  selector: 'app-order',
  templateUrl: './order.component.html',
  styleUrls: ['./order.component.css']
})
export class OrderComponent implements OnInit {

  @Input()
  stockCode: string;

  @Input()
  amount: number;

  constructor() { }

  ngOnInit() {
  }

}

```

`/src/app/order/order.component.html`

```html
<div>
  我是下单组件
</div>
<div>
  买{{amount}}手{{stockCode}}股票
</div>
```

说明:

- `@Input()` 输入属性声明需要装饰器
- 当一个组件声明了输入属性后
- 输入属性的值是在父组件的视图模板中设置

### 在父组件中设置子组件的输入属性值

`/src/app/app.component.ts`

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  stock = '';
}

```

`/src/app/app.component.html`

```html
<div>
  我是父组件
</div>
<div>
  <input type="text" placeholder="请输入股票代码" [(ngModel)]="stock">
  <app-order [stockCode]="stock" [amount]="100"></app-order>
</div>
```

### 输入属性的说明

- 输入属性在子组件中声明
- 只有声明为输入属性,才能在父组件的模板中使用 属性绑定方式 `[属性]=`
- 输入属性是单向的,即 从父组件的作用域 绑定到 子组件的属性上
- 子组件属性的值如果有变化,不会影响父组件


## 输出属性

- 输出属性 应理解为 输出事件 或 发射事件

- 子组件通过 发射事件 来实现向父组件传递数据的目的

- 子组件发射事件时, 会将 数据绑定到 `$event` 对象上

- 父组件需要捕捉事件, 并通过 `$event` 获取数据


### 子组件定义输出事件属性

`/src/app/price-quote/price-quote.component.ts`


```ts
import { Component, OnInit, EventEmitter, Output } from '@angular/core';

@Component({
  selector: 'app-price-quote',
  templateUrl: './price-quote.component.html',
  styleUrls: ['./price-quote.component.css']
})
export class PriceQuoteComponent implements OnInit {

  stockCode = 'IBM';

  price: number;

  // @Output()
  // lastPrice: EventEmitter<PriceQuote> = new EventEmitter();

  // tslint:disable-next-line:no-output-rename
  @Output('priceChange')
  lastPrice: EventEmitter<PriceQuote> = new EventEmitter();

  constructor() {
    setInterval(() => {
      const priceQuote: PriceQuote = new PriceQuote(this.stockCode,
        100 * Math.random());
      this.price = priceQuote.lastPrice;

      this.lastPrice.emit(priceQuote);
    }, 1000);
  }

  ngOnInit() {
  }

}

export class PriceQuote {

  constructor(public stockCode: string,
    public lastPrice: number
  ) {

  }

}


```

在定义输出事件属性时,可以另外指定事件名称,但不推荐

(不推荐)
```ts 
  @Output('priceChange')
  lastPrice: EventEmitter<PriceQuote> = new EventEmitter();
```

定义输出事件后,调出事件属性的`emit`方法,发射数据

```
this.lastPrice.emit(priceQuote);
```

### 父组件捕捉事件

`/src/app/app.component.html`

```html
<!--<app-price-quote (lastPrice)="priceQuoteHndler($event)"></app-price-quote>-->
<app-price-quote (priceChange)="priceQuoteHndler($event)"></app-price-quote>
<div>
  这是在报价组件外部,股票代码是{{priceQuote.stockCode}}, 股票价格是{{priceQuote.lastPrice| number:'2.2-2'}}
</div>
```

事件名称跟`@Output`定义要相同

`/src/app/app.component.ts`

```ts
import { Component } from '@angular/core';
import { PriceQuote } from './price-quote/price-quote.component';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  stock = '';

  priceQuote: PriceQuote = new PriceQuote('', 0);

  priceQuoteHndler(event: PriceQuote) {
    this.priceQuote = event;
    console.log(event);
  }

}

```

## 中间人模式

两个组件是兄弟关系,或没有直接联系时,

需要通过中间人完成数据交换,

通常中间人由 组件共同的父组件, 或者 服务来实现


### 修改报价组件

`/src/app/price-quote/price-quote.component.html`

```ts
<div>
  我是报价组件
</div>
<div>
  股票代码是{{stockCode}}，股票价格是{{price | number:'2.2-2'}}
</div>
<div>
  <input type="button" value="立即购买" (click)="buyStock($event)">
</div>
```

